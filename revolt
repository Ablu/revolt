#! /usr/bin/env python3
# -*- coding: utf-8 -*-
# vim:fenc=utf-8
#
# Copyright © 2016 Adrian Perez <aperez@igalia.com>
#
# Distributed under terms of the MIT license.

import gi
gi.require_version('WebKit2', '4.0')

from gi.repository import WebKit2, Gtk, Gio, Gdk  # noqa: E402


APP_ID = "org.perezdecastro.Revolt"
APP_COMMENTS = u"Desktop application for Riot.im"
APP_WEBSITE = u"https://github.com/aperezdc/revolt"
APP_AUTHORS = (
    u"Adrián Pérez de Castro <aperez@igalia.com>",
    u"Jacobo Aragunde Pérez <jaragunde@igalia.com>",
    u"Carlos López Pérez <clopez@igalia.com>",
)


def _find_resources_path():
    from os import environ, path as P
    devel = environ.get("__REVOLT_DEVELOPMENT")
    if devel and devel.strip():
        # Use the directory where the executable is located, most likely
        # a checkout of the Git repository.
        path = P.dirname(__file__)
    else:
        # Use an installed location: binary is in <prefix>/bin/revolt,
        # and resources in <prefix>/share/revolt/*
        path = P.join(P.dirname(P.dirname(__file__)), "share", "revolt")
    location = P.abspath(P.join(path, APP_ID + ".gresource"))
    print("* Resources:", location)
    return location


class MainWindow(object):
    def __init__(self, app):
        self.__app = app
        self._webctx = self.__create_web_context()
        self._contentmgr = self.__create_content_manager()
        self.__create_widgets()
        self.__connect_widgets()
        self.__notification_ids = set()

    def __create_web_context(self):
        ctx = WebKit2.WebContext.get_default()
        ctx.set_web_process_count_limit(1)
        ctx.set_spell_checking_enabled(False)
        ctx.set_tls_errors_policy(WebKit2.TLSErrorsPolicy.FAIL)
        return ctx

    def __create_content_manager(self):
        mgr = WebKit2.UserContentManager()
        script = WebKit2.UserScript("Notification.requestPermission();",
                                    WebKit2.UserContentInjectedFrames.TOP_FRAME,
                                    WebKit2.UserScriptInjectionTime.START,
                                    None, None)
        mgr.add_script(script)
        return mgr

    def __create_widgets(self):
        header = Gtk.HeaderBar()
        header.set_show_close_button(True)

        self.__app.settings.bind("riot-url", header, "subtitle",
                                 Gio.SettingsBindFlags.DEFAULT)
        header.set_has_subtitle(True)

        self._spinner = Gtk.Spinner()
        header.pack_end(self._spinner)

        self._window = Gtk.ApplicationWindow()
        self._window.set_titlebar(header)
        self._window.set_title("Revolt")
        self._window.set_default_icon_name(APP_ID)
        self._window.set_default_size(980, 650)
        self.__app.add_window(self._window)

        self._webview = WebKit2.WebView(user_content_manager=self._contentmgr,
                                        web_context=self._webctx)
        self._webview.connect("decide-policy", self.__on_decide_policy)
        self.__app.settings.bind("zoom-factor", self._webview, "zoom-level",
                                 Gio.SettingsBindFlags.DEFAULT)
        if hasattr(self._webview, "set_maintains_back_forward_list"):
            self._webview.set_maintains_back_forward_list(False)
        websettings = self._webview.get_settings()
        websettings.set_allow_file_access_from_file_urls(True)
        websettings.set_allow_modal_dialogs(False)  # TODO
        websettings.set_enable_fullscreen(False)
        websettings.set_enable_java(False)
        websettings.set_enable_media_stream(True)
        websettings.set_enable_page_cache(False)  # Single-page app
        websettings.set_enable_plugins(False)
        websettings.set_enable_smooth_scrolling(True)
        websettings.set_enable_webaudio(True)
        websettings.set_enable_write_console_messages_to_stdout(True)
        websettings.set_javascript_can_access_clipboard(True)
        websettings.set_minimum_font_size(12)  # TODO: Make it a setting
        websettings.set_property("enable-mediasource", True)
        self._window.add(self._webview)

    def __on_decide_policy(self, webview, decision, decision_type):
        if decision_type == WebKit2.PolicyDecisionType.NAVIGATION_ACTION:
            if decision.get_navigation_type() == WebKit2.NavigationType.LINK_CLICKED:
                uri = decision.get_request().get_uri()
                if not uri.startswith(self.__app.riot_url):
                    Gtk.show_uri(uri)
                    return True
        elif decision_type == WebKit2.PolicyDecisionType.NEW_WINDOW_ACTION:
            if decision.get_navigation_type() == WebKit2.NavigationType.LINK_CLICKED:
                Gtk.show_uri(None, decision.get_request().get_uri(), Gdk.CURRENT_TIME)
                return True
        return False

    def __on_has_toplevel_focus_changed(self, window, has_focus):
        assert window == self._window
        if window.has_toplevel_focus():
            # Clear the window's urgency hint
            window.set_urgency_hint(False)
            # Dismiss notifications
            for notification_id in self.__notification_ids:
                self.__app.withdraw_notification(notification_id)
            self.__notification_ids.clear()

    def __on_window_close(self, window):
        # TODO: Do cleanup here
        window.hide()
        return False

    def __on_load_changed(self, webview, event):
        if event == WebKit2.LoadEvent.FINISHED:
            self._spinner.stop()
        else:
            self._spinner.start()

    def __on_show_notification(self, webview, notification):
        # TODO: Handle notification clicked, and so
        if not self._window.has_toplevel_focus():
            self._window.set_urgency_hint(True)
            notif = Gio.Notification.new(notification.get_title())
            notif.set_body(notification.get_body())
            notif.set_icon(Gio.ThemedIcon.new(APP_ID))
            notif.set_priority(Gio.NotificationPriority.HIGH)
            # use title as notification id:
            # allows to reuse one notification for the same conversation
            notification_id = notification.get_title()
            self.__notification_ids.add(notification_id)
            self.__app.send_notification(notification_id, notif)
        return True

    def __on_permission_request(self, webview, request):
        if isinstance(request, WebKit2.NotificationPermissionRequest):
            request.allow()
            return True

    def __connect_widgets(self):
        self._window.connect("destroy", self.__on_window_close)
        self._window.connect("notify::has-toplevel-focus", self.__on_has_toplevel_focus_changed)
        self._webview.connect("load-changed", self.__on_load_changed)
        self._webview.connect("show-notification", self.__on_show_notification)
        self._webview.connect("permission-request", self.__on_permission_request)

    def load_riot(self):
        self._webview.load_uri(self.__app.riot_url)
        return self

    def show(self):
        self._window.show_all()
        self._window.present()
        return self

    def finish(self):
        print("Finish...")
        self._webview.stop_loading()
        self._window.hide()
        self._window.destroy()
        del self._webview
        return self


class App(Gtk.Application):
    def __init__(self):
        Gtk.Settings.get_default().set_property("gtk-application-prefer-dark-theme", True)
        Gio.Resource.load(_find_resources_path())._register()
        Gtk.Application.__init__(self, application_id=APP_ID,
                                 flags=Gio.ApplicationFlags.FLAGS_NONE)
        self.settings = Gio.Settings.new(APP_ID)
        self.riot_url = self.settings.get_string("riot-url")
        self.window = None
        self.connect("shutdown", self.__on_shutdown)
        self.connect("activate", self.__on_activate)
        self.connect("startup", self.__on_startup)

    def __action(self, name, callback):
        action = Gio.SimpleAction.new(name)
        action.connect("activate", callback)
        self.add_action(action)

    def __on_startup(self, app):
        print("* App Startup...")
        self.__action("quit", lambda *arg: self.quit())
        self.__action("about", self.__on_app_about)
        self.__action("preferences", self.__on_app_preferences)

    def __on_shutdown(self, app):
        print("* App Shutdown...")
        if self.window is not None:
            self.window.finish()

    def __on_activate(self, app):
        print("* App Activated...")
        if self.window is None:
            self.window = MainWindow(self).load_riot()
        self.window.show()

    def __on_app_about(self, action, param):
        dialog = Gtk.AboutDialog(
                program_name=u"Revolt",
                authors=APP_AUTHORS,
                logo_icon_name=APP_ID,
                license_type=Gtk.License.GPL_3_0,
                comments=APP_COMMENTS,
                website=APP_WEBSITE)
        dialog.connect("response", lambda d, r: d.destroy())
        dialog.present()

    def __build(self, resource, *names):
        builder = Gtk.Builder.new_from_resource(self.get_resource_base_path() + "/" + resource)
        return (builder.get_object(name) for name in names)

    def __on_app_preferences(self, action, param):
        window, url_entry, zoom_factor, zoom_factor_reset = \
                self.__build("gtk/preferences.ui",
                             "settings-window",
                             "riot-url-entry",
                             "zoom-factor",
                             "zoom-factor-reset")
        self.settings.bind("zoom-factor", zoom_factor, "value",
                           Gio.SettingsBindFlags.DEFAULT)
        zoom_factor_reset.connect("clicked", lambda button:
                                  self.settings.set_double("zoom-factor", 1.0))
        url_entry.set_text(self.riot_url)

        def on_hide(window):
            new_url = url_entry.get_text()
            if new_url != self.riot_url:
                self.settings.set_string("riot-url", new_url)
                self.riot_url = new_url
                self.window.load_riot()
        window.connect("hide", on_hide)
        window.set_transient_for(self.window._window)  # XXX: Ugh.
        window.present()


if __name__ == "__main__":
    # Honor CTRL+C http://stackoverflow.com/q/16410852
    import signal
    import sys
    signal.signal(signal.SIGINT, signal.SIG_DFL)
    App().run(sys.argv[1:])
